package tutor_agent

import (
	"bufio"
	"context"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/smallnest/langgraphgo/graph"
	"github.com/tmc/langchaingo/llms"
	"github.com/tmc/langchaingo/llms/openai"
)

type LLMType int

const (
	OpenAI LLMType = iota
	Ollama
)

// Tutor agent state definition
type TutorState struct {
	// Documents contents
	DocumentContents map[string]string
	// Generated by the Agent
	DocumentSummary string
	// Chat history
	Messages []llms.MessageContent
	// User input
	UserInput string
	// Whether the agent should continue
	ShouldContinue bool
	// Current teaching stage
	Stage string
}

type TutorAgent struct {
	model   llms.Model
	graph   *graph.StateRunnable[TutorState]
	scanner *bufio.Scanner
}

func NewTutorAgent(llmType LLMType) (*TutorAgent, error) {
	switch llmType {
	case OpenAI:
		return nil, errors.New("unsupported LLM type: OpenAI")
	case Ollama:
		return newOllamaTutorAgent()
	default:
		return nil, errors.New(fmt.Sprintf("unrecognized LLM type: %d", llmType))
	}
}

func newOllamaTutorAgent() (*TutorAgent, error) {
	// Config Ollama
	model, err := openai.New(
		openai.WithBaseURL("http://localhost:11434/v1"),
		openai.WithModel("deepseek-r1:14b"),
		openai.WithToken("ollama"),
	)
	if err != nil {
		return nil, fmt.Errorf("create LLM failed: %v", err)
	}

	agent := &TutorAgent{
		model:   model,
		scanner: bufio.NewScanner(os.Stdin),
	}

	if err := agent.buildGraph(); err != nil {
		return nil, err
	}

	return agent, nil
}

func (t *TutorAgent) buildGraph() error {
	g := graph.NewStateGraph[TutorState]()

	// 1. Load documents node
	g.AddNode("load_documents", "load documents", t.loadDocuments)

	// 2. Analyze documents node
	g.AddNode("analyze_documents", "analyze documents", t.analyzeDocuments)

	// 3. Chat node
	g.AddNode("chat", "chat", t.chat)

	// 4. Check continue node, no need the continue check again
	// g.AddNode("check_continue", "check continue", t.checkContinue)

	// Set edges
	g.AddEdge("load_documents", "analyze_documents")
	g.AddEdge("analyze_documents", "chat")

	// no need the check continue node anymore
	// g.AddEdge("chat", "check_continue")

	// Conditional edge: decide the flow based on whether the user wants to continue
	g.AddConditionalEdge("check", func(ctx context.Context, state TutorState) string {
		if state.ShouldContinue {
			return "chat" // continue chatting
		}
		return graph.END // end the session
	})

	// Set entry point
	g.SetEntryPoint("load_documents")

	// Compile the graph
	runnable, err := g.Compile()
	if err != nil {
		return err
	}

	t.graph = runnable
	return nil
}

func (t *TutorAgent) loadDocuments(ctx context.Context, state TutorState) (TutorState, error) {
	fmt.Println("\nğŸ“š === æ™ºèƒ½åŠ©æ•™ç³»ç»Ÿ ===")
	fmt.Println("æˆ‘å¯ä»¥å¸®åŠ©ä½ æ·±å…¥å­¦ä¹ å’Œç†è§£æ–‡æ¡£å†…å®¹ï¼")
	fmt.Println()

	// è·å–æ–‡ä»¶è·¯å¾„
	fmt.Print("è¯·è¾“å…¥è¦å­¦ä¹ çš„æ–‡æ¡£è·¯å¾„ï¼ˆå¤šä¸ªæ–‡ä»¶ç”¨é€—å·åˆ†éš”ï¼‰: ")
	if !t.scanner.Scan() {
		return state, fmt.Errorf("è¯»å–è¾“å…¥å¤±è´¥")
	}

	pathsInput := strings.TrimSpace(t.scanner.Text())
	if pathsInput == "" {
		return state, fmt.Errorf("æœªæä¾›æ–‡æ¡£è·¯å¾„")
	}

	// è§£æè·¯å¾„
	paths := strings.Split(pathsInput, ",")
	state.DocumentContents = make(map[string]string)

	// åŠ è½½æ¯ä¸ªæ–‡ä»¶
	for _, path := range paths {
		path = strings.TrimSpace(path)
		content, err := t.loadFile(path)
		if err != nil {
			fmt.Printf("âš ï¸  åŠ è½½æ–‡ä»¶ %s å¤±è´¥: %v\n", path, err)
			continue
		}
		state.DocumentContents[path] = content
		fmt.Printf("âœ… å·²åŠ è½½: %s (%d å­—ç¬¦)\n", filepath.Base(path), len(content))
	}

	if len(state.DocumentContents) == 0 {
		return state, fmt.Errorf("æ²¡æœ‰æˆåŠŸåŠ è½½ä»»ä½•æ–‡æ¡£")
	}

	state.Stage = "documents_loaded"
	return state, nil
}

// loadFile åŠ è½½å•ä¸ªæ–‡ä»¶
func (t *TutorAgent) loadFile(path string) (string, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

// analyzeDocuments ä½¿ç”¨ AI åˆ†ææ–‡æ¡£å†…å®¹
func (t *TutorAgent) analyzeDocuments(ctx context.Context, state TutorState) (TutorState, error) {
	fmt.Println("\nğŸ” æ­£åœ¨åˆ†ææ–‡æ¡£å†…å®¹...")

	// æ„å»ºæ–‡æ¡£å†…å®¹æ‘˜è¦
	var docsBuilder strings.Builder
	docsBuilder.WriteString("ä»¥ä¸‹æ˜¯éœ€è¦å­¦ä¹ çš„æ–‡æ¡£å†…å®¹ï¼š\n\n")

	for path, content := range state.DocumentContents {
		docsBuilder.WriteString(fmt.Sprintf("=== æ–‡ä»¶: %s ===\n", filepath.Base(path)))
		// å¦‚æœæ–‡æ¡£å¤ªé•¿ï¼Œæˆªå–å‰é¢éƒ¨åˆ†
		if len(content) > 8000 {
			docsBuilder.WriteString(content[:8000])
			docsBuilder.WriteString("\n\n[æ–‡æ¡£å†…å®¹è¿‡é•¿ï¼Œå·²æˆªå–å‰ 8000 å­—ç¬¦]\n\n")
		} else {
			docsBuilder.WriteString(content)
			docsBuilder.WriteString("\n\n")
		}
	}

	// è®© AI åˆ†ææ–‡æ¡£
	analysisPrompt := docsBuilder.String() + `

è¯·ä½œä¸ºä¸€ä½ä¸“ä¸šçš„åŠ©æ•™ï¼Œå®Œæˆä»¥ä¸‹ä»»åŠ¡ï¼š
1. ç®€è¦æ¦‚è¿°è¿™äº›æ–‡æ¡£çš„ä¸»è¦å†…å®¹å’Œæ ¸å¿ƒæ¦‚å¿µ
2. åˆ—å‡ºæ–‡æ¡£ä¸­çš„é‡ç‚¹çŸ¥è¯†ç‚¹
3. è¯´æ˜ä½ å°†å¦‚ä½•å¸®åŠ©å­¦ä¹ è€…ç†è§£è¿™äº›å†…å®¹

è¯·ç”¨å‹å¥½ã€æ˜“æ‡‚çš„è¯­è¨€å›å¤ã€‚`

	messages := []llms.MessageContent{
		llms.TextParts(llms.ChatMessageTypeHuman, analysisPrompt),
	}

	response, err := t.model.GenerateContent(ctx, messages,
		llms.WithTemperature(0.7),
		llms.WithMaxTokens(2000),
	)
	if err != nil {
		return state, fmt.Errorf("åˆ†ææ–‡æ¡£å¤±è´¥: %v", err)
	}

	state.DocumentSummary = response.Choices[0].Content

	// åˆå§‹åŒ–å¯¹è¯å†å²ï¼ŒåŒ…å«æ–‡æ¡£å†…å®¹å’Œæ¦‚è¿°
	state.Messages = []llms.MessageContent{
		llms.TextParts(llms.ChatMessageTypeSystem,
			fmt.Sprintf(`ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„åŠ©æ•™ï¼Œå¸®åŠ©å­¦ä¹ è€…æ·±å…¥ç†è§£ä»¥ä¸‹æ–‡æ¡£å†…å®¹ã€‚

%s

ä½ çš„ä»»åŠ¡æ˜¯ï¼š
1. å›ç­”å­¦ä¹ è€…å…³äºæ–‡æ¡£å†…å®¹çš„é—®é¢˜
2. æä¾›æ·±å…¥çš„è§£é‡Šå’Œç¤ºä¾‹
3. å¼•å¯¼å­¦ä¹ è€…æ€è€ƒå’Œæ¢ç´¢
4. ç”¨æ¸…æ™°ã€å‹å¥½çš„è¯­è¨€äº¤æµ

è¯·åŸºäºæ–‡æ¡£å†…å®¹å›ç­”é—®é¢˜ï¼Œå¦‚æœéœ€è¦ä¸¾ä¾‹è¯´æ˜ï¼Œå¯ä»¥ä»æ–‡æ¡£ä¸­æå–ç›¸å…³å†…å®¹ã€‚`, docsBuilder.String())),
		llms.TextParts(llms.ChatMessageTypeAI, state.DocumentSummary),
	}

	fmt.Println("\n" + strings.Repeat("=", 60))
	fmt.Printf("ğŸ“ åŠ©æ•™åˆ†æï¼š\n\n%s\n", state.DocumentSummary)
	fmt.Println(strings.Repeat("=", 60))
	fmt.Println("\nğŸ’¡ æç¤ºï¼šè¾“å…¥ 'quit' æˆ– 'exit' å¯ä»¥é€€å‡ºï¼Œç›´æ¥å›è½¦ä¹Ÿä¼šé€€å‡º")

	state.Stage = "analysis_complete"
	state.ShouldContinue = true
	return state, nil
}

// chat å¯¹è¯äº¤äº’ - æ”¯æŒå¤šè½®å¯¹è¯
func (t *TutorAgent) chat(ctx context.Context, state TutorState) (TutorState, error) {
	// è·å–ç”¨æˆ·è¾“å…¥
	fmt.Print("\nğŸ’¬ ä½ çš„é—®é¢˜: ")
	if !t.scanner.Scan() {
		state.ShouldContinue = false
		return state, nil
	}

	userInput := strings.TrimSpace(t.scanner.Text())
	state.UserInput = userInput

	// æ£€æŸ¥é€€å‡ºå‘½ä»¤
	if userInput == "quit" || userInput == "exit" || userInput == "" {
		state.ShouldContinue = false
		fmt.Println("\nğŸ‘‹ æ„Ÿè°¢ä½¿ç”¨æ™ºèƒ½åŠ©æ•™ç³»ç»Ÿï¼ç¥å­¦ä¹ æ„‰å¿«ï¼")
		return state, nil
	}

	// æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
	state.Messages = append(state.Messages,
		llms.TextParts(llms.ChatMessageTypeHuman, userInput))

	// è°ƒç”¨ AI ç”Ÿæˆå›å¤
	fmt.Print("ğŸ¤– åŠ©æ•™æ€è€ƒä¸­...")

	response, err := t.model.GenerateContent(ctx, state.Messages,
		llms.WithTemperature(0.7),
		llms.WithMaxTokens(3000),
	)
	if err != nil {
		fmt.Printf("\nâŒ ç”Ÿæˆå›å¤å¤±è´¥: %v\n", err)
		// å³ä½¿å‡ºé”™ä¹Ÿç»§ç»­å¯¹è¯
		state.ShouldContinue = true
		return state, nil
	}

	fmt.Print("\r" + strings.Repeat(" ", 30) + "\r") // æ¸…é™¤"æ€è€ƒä¸­"æç¤º

	aiResponse := response.Choices[0].Content

	// æ·»åŠ  AI å›å¤åˆ°å†å²
	state.Messages = append(state.Messages,
		llms.TextParts(llms.ChatMessageTypeAI, aiResponse))

	// æ˜¾ç¤ºå›å¤
	fmt.Printf("ğŸ“ åŠ©æ•™ï¼š\n%s\n", aiResponse)

	// ç»§ç»­å¯¹è¯å¾ªç¯
	state.ShouldContinue = true
	state.Stage = "chat_complete"
	return state, nil
}

// Run è¿è¡ŒåŠ©æ•™ç³»ç»Ÿ
func (t *TutorAgent) Run() error {
	ctx := context.Background()

	// åˆå§‹åŒ–çŠ¶æ€
	initialState := TutorState{
		DocumentContents: make(map[string]string),
		Messages:         []llms.MessageContent{},
		ShouldContinue:   true,
		Stage:            "init",
	}

	// æ‰§è¡Œå·¥ä½œæµ
	finalState, err := t.graph.Invoke(ctx, initialState)
	if err != nil {
		return fmt.Errorf("æ‰§è¡Œå¤±è´¥: %v", err)
	}

	// ç»“æŸæç¤º
	if finalState.Stage != "init" {
		fmt.Println("\nğŸ‘‹ æ„Ÿè°¢ä½¿ç”¨æ™ºèƒ½åŠ©æ•™ç³»ç»Ÿï¼ç¥å­¦ä¹ æ„‰å¿«ï¼")
	}

	return nil
}
